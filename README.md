# CS232-POPL 2: Large Code Bases and OOP
### Ananya Mantravadi - CS19B1004
### Introduction

The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Clang is not only a C, C++, Objective-C, or Objective-C++ compiler that is compiled in C++ based on LLVM, but also an infrastructure to build tools. Clang uses a recursive-descent parser. It is mainly used for better performance than GCC.

There are three phases in Clang compilation:

*   The front end: It parses source code, checking it for errors, and builds a language-specific Abstract Syntax Tree (AST) to represent the input code.
*   The optimizer: Its goal is to do some optimization on the AST generated by the front end.
*   The back end: It generates the final code to be executed by the machine that depends on the target.

### C++11/C++14 features used

*   Use of auto keyword for automatic type detection
*   Use of nullptr in place of 0 or NULL
*   A new version of the range-based for loop that iterates over all elements of a collection.

     [https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/Parser.cpp#L565 ](https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/Parser.cpp#L565)

*   Usage of std::unique_ptr, as a replacement for std::auto_ptr

    [https://github.com/llvm/llvm-project/blob/main/pstl/test/std/utilities/memory/specialized.algorithms/uninitialized_fill_destroy.pass.cpp#L74](https://github.com/llvm/llvm-project/blob/main/pstl/test/std/utilities/memory/specialized.algorithms/uninitialized_fill_destroy.pass.cpp#L74)

*   Use of lambdas, which allow the definition of inline functions, working as a parameter or a local object.

    [https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/Parser.cpp#L1052](https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/Parser.cpp#L1052)

*   Use of static_cast for conversions from pointers to related classes, implicit conversions, etc. which is a compile-time cast.

    [https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/Parser.cpp#L267](https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/Parser.cpp#L267)

*   Use of enum classes that makes enumerations both strongly typed and strongly scoped.

    [https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Sema/DeclSpec.h#L1754](https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Sema/DeclSpec.h#L1754)

*   Use of constexpr for computations at compile-time instead of run-time.

    [https://github.com/llvm/llvm-project/blob/main/pstl/test/std/numerics/numeric.ops/adjacent_difference.pass.cpp#L38](https://github.com/llvm/llvm-project/blob/main/pstl/test/std/numerics/numeric.ops/adjacent_difference.pass.cpp#L38)

*   Use of static_assert which performs compile-time assertion checking.

    [https://github.com/llvm/llvm-project/blob/main/pstl/test/pstl/version.pass.cpp#L11](https://github.com/llvm/llvm-project/blob/main/pstl/test/pstl/version.pass.cpp#L11)

*   Use of ‘=default;’ specifier at the end of a function to declare it as an explicitly defaulted function.

    [https://github.com/llvm/llvm-project/blob/main/llvm/lib/Analysis/StratifiedSets.h#L86](https://github.com/llvm/llvm-project/blob/main/llvm/lib/Analysis/StratifiedSets.h#L86)

*   Use of fixed-width integer types such as unit64_t (unsigned integer type with width of exactly 16 bits)

    [https://github.com/llvm/llvm-project/blob/main/llvm/lib/Analysis/VectorUtils.cpp#L483](https://github.com/llvm/llvm-project/blob/main/llvm/lib/Analysis/VectorUtils.cpp#L483)


### Class hierarchy
Clang’s AST nodes are modeled on a class hierarchy that does not have a common ancestor. Instead, there are multiple larger hierarchies for basic node types like Decl and Stmt. Many important AST nodes derive from Type, Decl, DeclContext or Stmt, with some classes deriving from both Decl and DeclContext.
The following link contains the class hierarchy from [LLVM doxygen documentation](https://llvm.org/doxygen/) which is a useful source of information about the LLVM source base - [https://llvm.org/doxygen/inherits.html](https://llvm.org/doxygen/inherits.html)


### OOP design decisions for LLVM

*   Inheritance: It is a process in which one object acquires all the properties and behaviors of its parent object automatically. 

    [https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/Parser.cpp#L30](https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/Parser.cpp#L30)

*   Multiple inheritance: Classes inheriting from more than one concrete class

    [https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/ADT/ilist.h#L166](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/ADT/ilist.h#L166)

*   [Virtual Methods](https://llvm.org/docs/CodingStandards.html#provide-a-virtual-method-anchor-for-classes-in-headers): If a class is defined in a header file and has a vtable (either it has virtual methods or it derives from classes with virtual methods), it always has at least one out-of-line virtual method in the class. Many methods are virtual, and some of them are pure virtual.
*   Modularity: A major design concept for clang is its use of a library-based architecture to be modular. Each compilation phase consists of multiple modules. This approach leads to well-defined interfaces, good abstraction and makes the code more readable. Modularity is also achieved using namespaces with enums, enum classes, and anonymous namespaces.

    [https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/Parser.cpp#L27](https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/Parser.cpp#L27)

### Design Patterns

The following design patterns are incorporated into Clang/LLVM source code:

*   Factory Method Pattern: It provides an interface for creating an object, but lets subclasses decide which class to instantiate. It is useful to isolate the logic instantiation and enforces the cohesion.
*   Abstract Factory Pattern: It provides an interface for creating families of related or dependent objects without specifying their concrete classes.
*   Observer pattern: It defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
*   Visitor pattern: It lets you define a new operation without changing the classes of the elements on which it operates.
*   Low Coupling:  It can be achieved by using abstract classes, generic types, and methods and is desirable since changes in one area will require fewer changes throughout the entire application.

    [https://github.com/llvm/llvm-project/blob/main/clang/test/CXX/class.derived/class.abstract/p2.cpp#L10](https://github.com/llvm/llvm-project/blob/main/clang/test/CXX/class.derived/class.abstract/p2.cpp#L10)


### Usage of iterators and their own data structures:

*   Modules, Functions, and BasicBlocks, Value each provide iterators over their children.
*   The techniques used to traverse these various data structures are all basically the same.
*   `begin()` function (or method) returns an iterator to the start of the sequence, the `end()` function returns an iterator pointing to one past the last valid element of the sequence and there is some `iterator` data type that is common between the two operations.
*   User::op_iterator - iterates through operands
*   inst_iterator - goes through instructions in a function 
     * for(inst_iterator i=inst_begin(f);i!=inst_end(f);i++) 
     *  Declared in &lt;Transforms/Utils/FunctionUtils.h>
*   Most iterators automatically cast to a pointer to the object type (except inst_iterator)

### References:

*   [https://github.com/llvm/llvm-project](https://github.com/llvm/llvm-project)
*   [https://llvm.org/docs/CodingStandards.html#provide-a-virtual-method-anchor-for-classes-in-headers](https://llvm.org/docs/CodingStandards.html#provide-a-virtual-method-anchor-for-classes-in-headers)
*   [https://cppdepend.com/blog/?p=92](https://cppdepend.com/blog/?p=92)
*   [https://llvm.org/doxygen/](https://llvm.org/doxygen/)
*   [https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns)
*   [https://llvm.org/docs/ProgrammersManual.html#basic-inspection-and-traversal-routines](https://llvm.org/docs/ProgrammersManual.html#basic-inspection-and-traversal-routines)
*   [http://www.cs.cmu.edu/afs/cs/academic/class/15745-s12/public/lectures/L6-LLVM-Part2.pdf](http://www.cs.cmu.edu/afs/cs/academic/class/15745-s12/public/lectures/L6-LLVM-Part2.pdf)
*   [https://clang.llvm.org/docs/IntroductionToTheClangAST.html](https://clang.llvm.org/docs/IntroductionToTheClangAST.html)
